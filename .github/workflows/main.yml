name: user-service main-branch CI workflow

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

jobs:
  # í…ŒìŠ¤íŠ¸
  build:
    env:
      SPRING_PROFILES_ACTIVE: test
      JWT_SECRET: ${{ vars.TEST_JWT_SECRET }}

    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0

      - name: Build with Gradle Wrapper
        run: ./gradlew build

      - name: Configure AWS credentials
        if: failure()
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_S3_UPLOAD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_S3_UPLOAD }}
          aws-region: ap-northeast-2

      - name: Upload test report to S3 on failure
        if: failure()
        run: |
          RUN_ID="${GITHUB_RUN_ID}"
          if [ -d "build/reports/tests/test" ]; then
            aws s3 sync "build/reports/tests/test" \
              "s3://${{ secrets.S3_REPORT_BUCKET }}/reports/${RUN_ID}/" \
              --delete
          else
            echo "No test report directory found."
          fi

  # ë¹Œë“œ ì„±ê³µ ì‹œ ë„ì»¤ ì´ë¯¸ì§€ ë¹Œë“œ
  docker-image:
    name: Build and Push Docker Image
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      image_uri: ${{ steps.meta.outputs.tags }}
    permissions:
      contents: read
      id-token: write # OIDCë¡œ AWS ê¶Œí•œ ë°›ì„ ë•Œ í•„ìš”

    env:
      AWS_REGION: ${{ vars.AWS_REGION }} # ì“°ëŠ” ë¦¬ì „ìœ¼ë¡œ ë³€ê²½
      ECR_REPOSITORY: ${{ vars.AWS_ECR_REPOSITORY }} # ECR ë¦¬í¬ì§€í† ë¦¬ ì´ë¦„ (ë¯¸ë¦¬ ë§Œë“¤ì–´ë‘¬ì•¼ í•¨)
      IMAGE_STEP: ${{ vars.IMAGE_STEP }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 1) GitHub ACCESS KEY and SECRET KEYë¡œ ìê²©ì¦ëª…
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS identity
        run: aws sts get-caller-identity

      # 2) ECR ë¡œê·¸ì¸
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 3) Docker meta (ì´ë¯¸ì§€/íƒœê·¸ ìƒì„± ê·œì¹™)
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            # {commit sha}-{step} ê·œì¹™
            type=sha,format=short,suffix=-${{ env.IMAGE_STEP }}

      # 4) Build & Push to ECR
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy:
    name: Deploy to ECS
    needs:
      - build
      - docker-image
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write # OIDCë¡œ AWS ê¶Œí•œ ë°›ì„ ë•Œ í•„ìš”

    env:
      AWS_REGION: ${{ vars.AWS_REGION }}
      CLUSTER: ${{ vars.ECS_CLUSTER_NAME }}
      SERVICE: ${{ vars.ECS_SERVICE_NAME }}
      FAMILY: ${{ vars.ECS_TASK_FAMILY_NAME }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # í˜„ì¬ íƒœìŠ¤í¬ì •ì˜ì˜ ë‚´ìš© ì¡°íšŒ -> taskdef.json íŒŒì¼ì— ì €ì¥
      - name: Describe current task definition
        id: describe
        run: |
          aws ecs describe-task-definition \
            --task-definition $FAMILY \
            --query 'taskDefinition' > taskdef.json

      # taskdef.jsonì—ì„œ ì´ë¯¸ì§€URIë¥¼ ë³€ê²½í•œ new-tastkdef.json ìƒì„± -> new-taskdef.jsonìœ¼ë¡œ ìƒˆë¡œìš´ íƒœìŠ¤í¬ì •ì˜ ê°œì •(Revision) ë“±ë¡
      - name: Register new task definition revision
        id: register
        run: |
          IMAGE_URI="${{ needs.docker-image.outputs.image_uri }}"
          IMAGE_URI="$(echo "$IMAGE_URI" | head -n 1)"

          # describe ê²°ê³¼ì—ì„œ registerì— í•„ìš”í•œ í•„ë“œë§Œ ì¶”ì¶œí•˜ê³  null í•„ë“œëŠ” ì œê±°
          jq '{
            family: .family,
            taskRoleArn: .taskRoleArn,
            executionRoleArn: .executionRoleArn,
            networkMode: .networkMode,
            containerDefinitions: .containerDefinitions,
            volumes: .volumes,
            placementConstraints: .placementConstraints,
            requiresCompatibilities: .requiresCompatibilities,
            cpu: .cpu,
            memory: .memory,
            tags: .tags,
            pidMode: .pidMode,
            ipcMode: .ipcMode,
            proxyConfiguration: .proxyConfiguration,
            inferenceAccelerators: .inferenceAccelerators,
            ephemeralStorage: .ephemeralStorage,
            runtimePlatform: .runtimePlatform
          } | del(.[] | nulls)' taskdef.json > clean-taskdef.json

          # ì´ë¯¸ì§€ URI êµì²´
          jq --arg image "$IMAGE_URI" \
            '.containerDefinitions[0].image = $image' \
            clean-taskdef.json > new-taskdef.json

          # null ê°’ ì™„ì „íˆ ì œê±° (ì¤‘ì²© í•„ë“œê¹Œì§€)
          jq 'walk(if type == "object" then with_entries(select(.value != null)) else . end)' \
            new-taskdef.json > final-taskdef.json

          # ìƒˆ ê°œì • ë“±ë¡
          REVISION=$(aws ecs register-task-definition \
            --cli-input-json file://final-taskdef.json \
            --query 'taskDefinition.revision' \
            --output text)

          echo "REVISION=$REVISION" >> $GITHUB_ENV
          echo "âœ… Registered new task definition revision: $REVISION"

      # ECS ì„œë¹„ìŠ¤ ì—…ë°ì´íŠ¸ -> ìƒˆë¡œìš´ íƒœìŠ¤í¬ì •ì˜ ê°œì •(Revision) ì ìš©
      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster $CLUSTER \
            --service $SERVICE \
            --task-definition ${FAMILY}:${REVISION} \
            --force-new-deployment

      # ECS ë°°í¬ ì™„ë£Œ ëŒ€ê¸° (ì°¸ê³ : 20ë¶„ ë‚´ì™¸ë¡œ ê±¸ë¦¬ê¸°ë„ í•¨)
      - name: Wait for ECS service stabilization
        run: |
          echo "â³ Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster $CLUSTER \
            --services $SERVICE
          echo "âœ… Service is stable."

  # í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ ì‹œ
  notify-slack-on-build-failure:
    name: Notify Slack on build failure
    needs:
      - build
    runs-on: ubuntu-latest
    if: ${{ always() && needs.build.result == 'failure' }} # ì‹¤íŒ¨í–ˆì„ ë•Œë§Œ ì‹¤í–‰
    steps:
      - name: Send Slack message on failure
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          CF_DOMAIN: ${{ vars.CF_REPORT_DOMAIN }} # ì˜ˆ: ci.goormdotcom.com
        run: |
          REPO="${GITHUB_REPOSITORY}"
          BRANCH_FROM="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}"   # PRì¼ ê²½ìš°: from ë¸Œëœì¹˜
          BRANCH_TO="${GITHUB_BASE_REF:-main}"                   # PRì¼ ê²½ìš°: target ë¸Œëœì¹˜
          RUN_ID="${GITHUB_RUN_ID}"
          GH_URL="https://github.com/${REPO}/actions/runs/${RUN_ID}"
          REPORT_URL="https://${CF_DOMAIN}/reports/${RUN_ID}/index.html"

          MESSAGE="âŒ *Build/Test Failed*

          *Repository* : \`${REPO}\`
          *Branch* : \`${BRANCH_FROM}\` â†’ \`${BRANCH_TO}\`

          *GitHub Run*: <${GH_URL}|View in GitHub>
          *Report* : <${REPORT_URL}|View HTML Report>"

          payload=$(jq -n --arg text "$MESSAGE" '{ text: $text }')

          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            "$SLACK_WEBHOOK_URL"

  # ì´ë¯¸ì§€ ë¹Œë“œ ì‹¤íŒ¨ ì‹œ
  notify-slack-on-image-build-failure:
    name: Notify Slack on image build failure
    needs:
      - docker-image
    runs-on: ubuntu-latest
    if: ${{ always() && needs.docker-image.result == 'failure' }}
    steps:
      - name: Send Slack message on failure
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

        run: |
          REPO="${GITHUB_REPOSITORY}"
          BRANCH_FROM="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}"   # PRì¼ ê²½ìš°: from ë¸Œëœì¹˜
          BRANCH_TO="${GITHUB_BASE_REF:-main}"                   # PRì¼ ê²½ìš°: target ë¸Œëœì¹˜
          RUN_ID="${GITHUB_RUN_ID}"
          GH_URL="https://github.com/${REPO}/actions/runs/${RUN_ID}"

          MESSAGE="âŒ *Image Build/Push Failed*

          *Repository* : \`${REPO}\`
          *Branch* : \`${BRANCH_FROM}\` â†’ \`${BRANCH_TO}\`

          *GitHub Run*: <${GH_URL}|View in GitHub>"

          payload=$(jq -n --arg text "$MESSAGE" '{ text: $text }')

          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            "$SLACK_WEBHOOK_URL"

  # Slack ì•Œë¦¼: ë°°í¬ ì‹¤íŒ¨ ì‹œ
  notify-slack-on-deploy-failure:
    name: Notify Slack on deploy failure
    needs:
      - deploy
    runs-on: ubuntu-latest
    if: ${{ always() && needs.deploy.result == 'failure' }} # ì‹¤íŒ¨í–ˆì„ ë•Œë§Œ ì‹¤í–‰
    steps:
      - name: Send Slack message on failure
        env:
          SLACK_URL_DEPLOY_RESULT: ${{ secrets.SLACK_URL_DEPLOY_RESULT }}
        run: |
          GH_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          MESSAGE="ğŸ˜± *FAILED - \`${{ vars.ECS_SERVICE_NAME }}\`*
          $(TZ=Asia/Seoul date '+%Y-%m-%d %H:%M:%S')
          <${GH_URL}|View in GitHub Run>
          "

          payload=$(jq -n \
            --arg text "$MESSAGE" \
            --arg color "danger" \
            '{ attachments: [ { color: $color, mrkdwn_in: ["text"], text: $text } ] }')

          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            "$SLACK_URL_DEPLOY_RESULT"

  # Slack ì•Œë¦¼: ì •ìƒì ìœ¼ë¡œ ë°°í¬ ì™„ë£Œ ì‹œ
  notify-slack-on-deploy-success:
    name: Notify Slack on deploy success
    needs:
      - deploy
    runs-on: ubuntu-latest
    if: ${{ always() && needs.deploy.result == 'success' }} # ì„±ê³µí–ˆì„ ë•Œë§Œ ì‹¤í–‰
    steps:
      - name: Send Slack message on success
        env:
          SLACK_URL_DEPLOY_RESULT: ${{ secrets.SLACK_URL_DEPLOY_RESULT }}
        run: |
          MESSAGE="ğŸ¥³ *SUCCESS - \`${{ vars.ECS_SERVICE_NAME }}\`*
          $(TZ=Asia/Seoul date '+%Y-%m-%d %H:%M:%S')
          "

          payload=$(jq -n \
            --arg text "$MESSAGE" \
            --arg color "good" \
            '{ attachments: [ { color: $color, mrkdwn_in: ["text"], text: $text } ] }')

          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            "$SLACK_URL_DEPLOY_RESULT"
