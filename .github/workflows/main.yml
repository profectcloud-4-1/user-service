name: user-service main-branch CI workflow

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

jobs:
  # ÌÖåÏä§Ìä∏
  # build:
  #   env:
  #     SPRING_PROFILES_ACTIVE: test
  #     JWT_SECRET: ${{ vars.TEST_JWT_SECRET }}

  #   runs-on: ubuntu-latest
  #   permissions:
  #     contents: read

  #   steps:
  #     - uses: actions/checkout@v4

  #     - name: Set up JDK 17
  #       uses: actions/setup-java@v4
  #       with:
  #         java-version: "17"
  #         distribution: "temurin"

  #     - name: Setup Gradle
  #       uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0

  #     - name: Build with Gradle Wrapper
  #       run: ./gradlew build

  #     - name: Configure AWS credentials
  #       if: failure()
  #       uses: aws-actions/configure-aws-credentials@v4
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_S3_UPLOAD }}
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_S3_UPLOAD }}
  #         aws-region: ap-northeast-2

  #     - name: Upload test report to S3 on failure
  #       if: failure()
  #       run: |
  #         RUN_ID="${GITHUB_RUN_ID}"
  #         if [ -d "build/reports/tests/test" ]; then
  #           aws s3 sync "build/reports/tests/test" \
  #             "s3://${{ secrets.S3_REPORT_BUCKET }}/reports/${RUN_ID}/" \
  #             --delete
  #         else
  #           echo "No test report directory found."
  #         fi

  # ÎπåÎìú ÏÑ±Í≥µ Ïãú ÎèÑÏª§ Ïù¥ÎØ∏ÏßÄ ÎπåÎìú
  docker-image:
    name: Build and Push Docker Image
    # needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      image_uri: ${{ steps.meta.outputs.tags }}
    permissions:
      contents: read
      id-token: write # OIDCÎ°ú AWS Í∂åÌïú Î∞õÏùÑ Îïå ÌïÑÏöî

    env:
      AWS_REGION: ${{ vars.AWS_REGION }} # Ïì∞Îäî Î¶¨Ï†ÑÏúºÎ°ú Î≥ÄÍ≤Ω
      ECR_REPOSITORY: ${{ vars.AWS_ECR_REPOSITORY }} # ECR Î¶¨Ìè¨ÏßÄÌÜ†Î¶¨ Ïù¥Î¶Ñ (ÎØ∏Î¶¨ ÎßåÎì§Ïñ¥Îë¨Ïïº Ìï®)
      IMAGE_STEP: ${{ vars.IMAGE_STEP }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 1) GitHub ACCESS KEY and SECRET KEYÎ°ú ÏûêÍ≤©Ï¶ùÎ™Ö
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS identity
        run: aws sts get-caller-identity

      # 2) ECR Î°úÍ∑∏Ïù∏
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 3) Docker meta (Ïù¥ÎØ∏ÏßÄ/ÌÉúÍ∑∏ ÏÉùÏÑ± Í∑úÏπô)
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            # {commit sha}-{step} Í∑úÏπô
            type=sha,format=short,suffix=-${{ env.IMAGE_STEP }}

      # 4) Build & Push to ECR
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy:
    name: Deploy to ECS
    needs:
      # - build
      - docker-image
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write # OIDCÎ°ú AWS Í∂åÌïú Î∞õÏùÑ Îïå ÌïÑÏöî

    env:
      AWS_REGION: ${{ vars.AWS_REGION }}
      CLUSTER: ${{ vars.ECS_CLUSTER_NAME }}
      SERVICE: ${{ vars.ECS_SERVICE_NAME }}
      FAMILY: ${{ vars.ECS_TASK_FAMILY_NAME }}
      DESIRED_COUNT: ${{ vars.ECS_DESIRED_COUNT }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ÌòÑÏû¨ ÌÉúÏä§ÌÅ¨Ï†ïÏùòÏùò ÎÇ¥Ïö© Ï°∞Ìöå -> taskdef.json ÌååÏùºÏóê Ï†ÄÏû•
      - name: Describe current task definition
        id: describe
        run: |
          aws ecs describe-task-definition \
            --task-definition $FAMILY \
            --query 'taskDefinition' > taskdef.json

      # taskdef.jsonÏóêÏÑú Ïù¥ÎØ∏ÏßÄURIÎ•º Î≥ÄÍ≤ΩÌïú new-tastkdef.json ÏÉùÏÑ± -> new-taskdef.jsonÏúºÎ°ú ÏÉàÎ°úÏö¥ ÌÉúÏä§ÌÅ¨Ï†ïÏùò Í∞úÏ†ï(Revision) Îì±Î°ù
      - name: Register new task definition revision
        id: register
        run: |
          IMAGE_URI="${{ needs.docker-image.outputs.image_uri }}"
          IMAGE_URI="$(echo "$IMAGE_URI" | head -n 1)"

          # describe Í≤∞Í≥ºÏóêÏÑú registerÏóê ÌïÑÏöîÌïú ÌïÑÎìúÎßå Ï∂îÏ∂úÌïòÍ≥† null ÌïÑÎìúÎäî Ï†úÍ±∞
          jq '{
            family: .family,
            taskRoleArn: .taskRoleArn,
            executionRoleArn: .executionRoleArn,
            networkMode: .networkMode,
            containerDefinitions: .containerDefinitions,
            volumes: .volumes,
            placementConstraints: .placementConstraints,
            requiresCompatibilities: .requiresCompatibilities,
            cpu: .cpu,
            memory: .memory,
            tags: .tags,
            pidMode: .pidMode,
            ipcMode: .ipcMode,
            proxyConfiguration: .proxyConfiguration,
            inferenceAccelerators: .inferenceAccelerators,
            ephemeralStorage: .ephemeralStorage,
            runtimePlatform: .runtimePlatform
          } | del(.[] | nulls)' taskdef.json > clean-taskdef.json

          # Ïù¥ÎØ∏ÏßÄ URI ÍµêÏ≤¥
          jq --arg image "$IMAGE_URI" \
            '.containerDefinitions[0].image = $image' \
            clean-taskdef.json > new-taskdef.json

          # null Í∞í ÏôÑÏ†ÑÌûà Ï†úÍ±∞ (Ï§ëÏ≤© ÌïÑÎìúÍπåÏßÄ)
          jq 'walk(if type == "object" then with_entries(select(.value != null)) else . end)' \
            new-taskdef.json > final-taskdef.json

          # ÏÉà Í∞úÏ†ï Îì±Î°ù
          REVISION=$(aws ecs register-task-definition \
            --cli-input-json file://final-taskdef.json \
            --query 'taskDefinition.revision' \
            --output text)

          echo "REVISION=$REVISION" >> $GITHUB_ENV
          echo "‚úÖ Registered new task definition revision: $REVISION"

      # ECS ÏÑúÎπÑÏä§ ÏóÖÎç∞Ïù¥Ìä∏ -> ÏÉàÎ°úÏö¥ ÌÉúÏä§ÌÅ¨Ï†ïÏùò Í∞úÏ†ï(Revision) Ï†ÅÏö©
      - name: Prepare swapped load balancers
        run: |
          aws ecs describe-services \
            --cluster $CLUSTER \
            --services $SERVICE \
            --query 'services[0].loadBalancers' > lb.json

          NUM=$(jq 'length' lb.json)
          if [ "$NUM" -lt 2 ]; then
            echo "LB_ARGS=" >> $GITHUB_ENV
            echo "No swap needed: found $NUM target group(s)."
            exit 0
          fi

          LB_ARGS=$(jq -r 'reverse[] | " --load-balancers targetGroupArn=\(.targetGroupArn),containerName=\(.containerName),containerPort=\(.containerPort)"' lb.json | tr -d '\n')
          echo "LB_ARGS=$LB_ARGS" >> $GITHUB_ENV
          echo "Prepared LB_ARGS: $LB_ARGS"

      - name: Update ECS service
        run: |
          ARGS="--cluster $CLUSTER --service $SERVICE --task-definition ${FAMILY}:${REVISION} --force-new-deployment"
          if [ -n "$DESIRED_COUNT" ]; then
            ARGS="$ARGS --desired-count $DESIRED_COUNT"
          fi
          aws ecs update-service $ARGS $LB_ARGS

      # ECS Î∞∞Ìè¨ ÏôÑÎ£å ÎåÄÍ∏∞ (Ï∞∏Í≥†: 20Î∂Ñ ÎÇ¥Ïô∏Î°ú Í±∏Î¶¨Í∏∞ÎèÑ Ìï®)
      - name: Wait for ECS service stabilization
        run: |
          TIMEOUT="${STABILIZE_TIMEOUT_SEC:-2400}"         # Í∏∞Î≥∏ 40Î∂Ñ
          INTERVAL="${STABILIZE_POLL_INTERVAL_SEC:-60}"    # Í∏∞Î≥∏ 60Ï¥à
          DEADLINE=$((SECONDS + TIMEOUT))
          echo "‚è≥ Waiting up to ${TIMEOUT}s for ECS service '$SERVICE' to stabilize (interval=${INTERVAL}s)..."

          while [ $SECONDS -lt $DEADLINE ]; do
            JSON=$(aws ecs describe-services \
              --cluster "$CLUSTER" \
              --services "$SERVICE" \
              --output json)

            STABLE=$(echo "$JSON" | jq -r '
              .services[0] as $s
              | (($s.deployments | length) == 1)
                and (
                  ($s.deployments[0].rolloutState // "") == "COMPLETED"
                  or (
                    ($s.deployments[0].status // "") == "PRIMARY"
                    and ($s.deployments[0].desiredCount // 0) == ($s.deployments[0].runningCount // -1)
                  )
                )
                and (($s.pendingCount // 0) == 0)
            ')

            if [ "$STABLE" = "true" ]; then
              echo "‚úÖ Service is stable."
              exit 0
            fi

            echo "‚Ä¶ still stabilizing. sleeping ${INTERVAL}s"
            sleep "$INTERVAL"
          done

          echo "‚ùå Timed out waiting for service stabilization after ${TIMEOUT}s"
          exit 1

  # # ÌÖåÏä§Ìä∏ Ïã§Ìå® Ïãú
  # notify-slack-on-build-failure:
  #   name: Notify Slack on build failure
  #   needs:
  #     - build
  #   runs-on: ubuntu-latest
  #   if: ${{ always() && needs.build.result == 'failure' }} # Ïã§Ìå®ÌñàÏùÑ ÎïåÎßå Ïã§Ìñâ
  #   steps:
  #     - name: Send Slack message on failure
  #       env:
  #         SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  #         CF_DOMAIN: ${{ vars.CF_REPORT_DOMAIN }} # Ïòà: ci.goormdotcom.com
  #       run: |
  #         REPO="${GITHUB_REPOSITORY}"
  #         BRANCH_FROM="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}"   # PRÏùº Í≤ΩÏö∞: from Î∏åÎûúÏπò
  #         BRANCH_TO="${GITHUB_BASE_REF:-main}"                   # PRÏùº Í≤ΩÏö∞: target Î∏åÎûúÏπò
  #         RUN_ID="${GITHUB_RUN_ID}"
  #         GH_URL="https://github.com/${REPO}/actions/runs/${RUN_ID}"
  #         REPORT_URL="https://${CF_DOMAIN}/reports/${RUN_ID}/index.html"

  #         MESSAGE="‚ùå *Build/Test Failed*

  #         *Repository* : \`${REPO}\`
  #         *Branch* : \`${BRANCH_FROM}\` ‚Üí \`${BRANCH_TO}\`

  #         *GitHub Run*: <${GH_URL}|View in GitHub>
  #         *Report* : <${REPORT_URL}|View HTML Report>"

  #         payload=$(jq -n --arg text "$MESSAGE" '{ text: $text }')

  #         curl -X POST -H 'Content-type: application/json' \
  #           --data "$payload" \
  #           "$SLACK_WEBHOOK_URL"

  # Ïù¥ÎØ∏ÏßÄ ÎπåÎìú Ïã§Ìå® Ïãú
  notify-slack-on-image-build-failure:
    name: Notify Slack on image build failure
    needs:
      - docker-image
    runs-on: ubuntu-latest
    if: ${{ always() && needs.docker-image.result == 'failure' }}
    steps:
      - name: Send Slack message on failure
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

        run: |
          REPO="${GITHUB_REPOSITORY}"
          BRANCH_FROM="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}"   # PRÏùº Í≤ΩÏö∞: from Î∏åÎûúÏπò
          BRANCH_TO="${GITHUB_BASE_REF:-main}"                   # PRÏùº Í≤ΩÏö∞: target Î∏åÎûúÏπò
          RUN_ID="${GITHUB_RUN_ID}"
          GH_URL="https://github.com/${REPO}/actions/runs/${RUN_ID}"

          MESSAGE="‚ùå *Image Build/Push Failed*

          *Repository* : \`${REPO}\`
          *Branch* : \`${BRANCH_FROM}\` ‚Üí \`${BRANCH_TO}\`

          *GitHub Run*: <${GH_URL}|View in GitHub>"

          payload=$(jq -n --arg text "$MESSAGE" '{ text: $text }')

          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            "$SLACK_WEBHOOK_URL"

  # Slack ÏïåÎ¶º: Î∞∞Ìè¨ Ïã§Ìå® Ïãú
  notify-slack-on-deploy-failure:
    name: Notify Slack on deploy failure
    needs:
      - deploy
    runs-on: ubuntu-latest
    if: ${{ always() && needs.deploy.result == 'failure' }} # Ïã§Ìå®ÌñàÏùÑ ÎïåÎßå Ïã§Ìñâ
    steps:
      - name: Send Slack message on failure
        env:
          SLACK_URL_DEPLOY_RESULT: ${{ secrets.SLACK_URL_DEPLOY_RESULT }}
        run: |
          GH_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          MESSAGE="üò± *FAILED - \`${{ vars.ECS_SERVICE_NAME }}\`*
          $(TZ=Asia/Seoul date '+%Y-%m-%d %H:%M:%S')
          <${GH_URL}|View in GitHub Run>
          "

          payload=$(jq -n \
            --arg text "$MESSAGE" \
            --arg color "danger" \
            '{ attachments: [ { color: $color, mrkdwn_in: ["text"], text: $text } ] }')

          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            "$SLACK_URL_DEPLOY_RESULT"

  # Slack ÏïåÎ¶º: Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Î∞∞Ìè¨ ÏôÑÎ£å Ïãú
  notify-slack-on-deploy-success:
    name: Notify Slack on deploy success
    needs:
      - deploy
    runs-on: ubuntu-latest
    if: ${{ always() && needs.deploy.result == 'success' }} # ÏÑ±Í≥µÌñàÏùÑ ÎïåÎßå Ïã§Ìñâ
    steps:
      - name: Send Slack message on success
        env:
          SLACK_URL_DEPLOY_RESULT: ${{ secrets.SLACK_URL_DEPLOY_RESULT }}
        run: |
          MESSAGE="ü•≥ *SUCCESS - \`${{ vars.ECS_SERVICE_NAME }}\`*
          $(TZ=Asia/Seoul date '+%Y-%m-%d %H:%M:%S')
          "

          payload=$(jq -n \
            --arg text "$MESSAGE" \
            --arg color "good" \
            '{ attachments: [ { color: $color, mrkdwn_in: ["text"], text: $text } ] }')

          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            "$SLACK_URL_DEPLOY_RESULT"
