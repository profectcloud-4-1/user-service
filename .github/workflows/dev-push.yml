name: User-service dev-branch push workflow

on:
  push:
    branches: [ "dev" ]

jobs:
  build-and-deploy:
    name: Build and Deploy Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      AWS_REGION: ${{ vars.AWS_REGION }}                 # Ïòà: ap-northeast-2
      ECR_REPOSITORY: ${{ vars.AWS_ECR_REPOSITORY }}     # Ïòà: goorm/app-service (Ïä¨ÎûòÏãú Í∞ÄÎä•)
      CONTAINER_NAME: ${{ vars.CONTAINER_NAME }}         # Ïòà: goorm-app-service (Ïä¨ÎûòÏãú X)

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.DEV_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.DEV_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS identity
        run: aws sts get-caller-identity

      # 1) ECR Î°úÍ∑∏Ïù∏ (Runner)
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 2) REGISTRYÎ•º envÎ°ú Ï†ÄÏû•
      - name: Set registry env
        run: echo "REGISTRY=${{ steps.login-ecr.outputs.registry }}" >> "$GITHUB_ENV"

      # 3) Docker meta (Ïù¥ÎØ∏ÏßÄ/ÌÉúÍ∑∏ ÏÉùÏÑ± Í∑úÏπô)
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            # sha ÌÉúÍ∑∏ ÌïòÎÇò (Ïòà: 9c1a3b2)
            type=sha,format=short

      # 4) IMAGE_NAME ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞
      - name: Export image info
        run: |
          # Ï≤´ Î≤àÏß∏ ÌÉúÍ∑∏Îßå ÏÇ¨Ïö© (ÌòïÌÉú: REGISTRY/REPO:TAG)
          IMAGE="$(echo "${{ steps.meta.outputs.tags }}" | head -n 1)"
          echo "IMAGE=$IMAGE" >> "$GITHUB_ENV"

      # 5) Build & Push to ECR
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      # 6) Deploy
      - name: Deploy via SSH to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEV_EC2_HOST }}
          username: ${{ secrets.DEV_EC2_USER }}
          key: ${{ secrets.DEV_EC2_SSH_KEY }}
          # Ïù¥ envsÏóê Ï†ÅÏùÄ Í≤ÉÎßå EC2 Ï™ΩÏúºÎ°ú ÎÑòÏñ¥Í∞ê
          envs: IMAGE,REGISTRY,AWS_REGION
          script: |
            # ÏóêÎü¨ ÎÇòÎ©¥ Î∞îÎ°ú Ïã§Ìå®
            set -Eeuo pipefail

            echo "== ECR Î°úÍ∑∏Ïù∏ (EC2) =="
            aws ecr get-login-password --region "$AWS_REGION" \
              | docker login --username AWS --password-stdin "$REGISTRY"

            echo "== ÏµúÏã† Ïù¥ÎØ∏ÏßÄ pull =="
            docker pull "$IMAGE" 
            
            echo "== Í∏∞Ï°¥ Ïª®ÌÖåÏù¥ÎÑà Ï¢ÖÎ£å Î∞è ÏÇ≠Ï†ú=="
            docker rm -f user-service 2>/dev/null || true
            
            echo "== ÏÉà Ïª®ÌÖåÏù¥ÎÑà Ïã§Ìñâ =="
            docker-compose up -d user-service

            echo "Î∞∞Ìè¨ ÏôÑÎ£å"

      - name: Wait for server restart (health check)
        env:
          HEALTH_URL: ${{ secrets.HEALTH_URL }}
        run: |
          echo "üîÑ Waiting for Server to restart..."
          for i in {1..30}; do
            if curl -s --head "$HEALTH_URL" | grep "200 OK" > /dev/null; then
              echo "‚úÖ Server is back online!"
              exit 0
            fi
            echo "‚è≥ Attempt $i: not ready yet... retrying in 10s"
            sleep 10
          done
          echo "‚ùå Server did not respond within 5 minutes."
          exit 1

  api-test:
    env:
      POSTMAN_COLLECTION_ID: ${{ secrets.POSTMAN_COLLECTION_ID }}
      POSTMAN_ENV_ID: ${{ secrets.POSTMAN_ENV_ID }}
      POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}

    name: Run Newman Test
    runs-on: ubuntu-latest
    needs: build-and-deploy
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install Newman
        run: npm install -g newman newman-reporter-htmlextra

      - name: Verify Newman installation
        run: newman --version

      - name: Run Newman tests
        run: |
          mkdir -p build/reports
          newman run "https://api.getpostman.com/collections/${POSTMAN_COLLECTION_ID}?apikey=${POSTMAN_API_KEY}" \
            -e "https://api.getpostman.com/environments/${POSTMAN_ENV_ID}?apikey=${POSTMAN_API_KEY}" \
            -r htmlextra \
            --reporter-htmlextra-export build/reports/report.html \
            --reporter-htmlextra-title "Dev server Test Report"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_S3_UPLOAD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_S3_UPLOAD }}
          aws-region: ap-northeast-2

      - name: Upload test report to S3
        run: |
          RUN_ID="${GITHUB_RUN_ID}"
          if [ -d "build/reports/" ]; then
            aws s3 cp build/reports/report.html \
              "s3://${{ secrets.S3_REPORT_BUCKET }}/reports/${RUN_ID}/report.html" \
              --content-type "text/html"
          else
            echo "No test report directory found."
          fi

  notify-slack-after-api-test:
    name: Notify Slack after api tests
    needs:
      - api-test
    runs-on: ubuntu-latest
    steps:
      - name: Send Slack message after api test
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          CF_DOMAIN: ${{ vars.CF_REPORT_DOMAIN }}
        run: |
          REPO="${GITHUB_REPOSITORY}"
          BRANCH_FROM="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}"   # PRÏùº Í≤ΩÏö∞: from Î∏åÎûúÏπò
          BRANCH_TO="${GITHUB_BASE_REF:-main}"                   # PRÏùº Í≤ΩÏö∞: target Î∏åÎûúÏπò
          RUN_ID="${GITHUB_RUN_ID}"
          GH_URL="https://github.com/${REPO}/actions/runs/${RUN_ID}"
          REPORT_URL="https://${CF_DOMAIN}/reports/${RUN_ID}/report.html"

          MESSAGE="The result of the API test üìÑ*

          *Repository* : \`${REPO}\`

          *GitHub Run*: <${GH_URL}|View in GitHub>
          *Report* : <${REPORT_URL}|View HTML Report>"

          payload=$(jq -n --arg text "$MESSAGE" '{ text: $text }')

          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            "$SLACK_WEBHOOK_URL"
